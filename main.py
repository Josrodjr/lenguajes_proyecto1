import copy

from libs.parser import parse_input, remove_empty
from tree.node import Node
from builder import create_node, name_parents
from tree.utils import FindDeepestNode


# try the print of the tree
from libs.print_tree import print2D
# try and print the nodes
from libs.grafo import graficadora
# get non_det functions
from finite_automata.automata import automata_template, create_or, create_and, create_kleene, create_plus, create_qmark

# get the array of parsed data
# operations = parse_input('(a|b)* a b')
# operations = parse_input('(a|b)* c d')
operations = parse_input('(c?)* a')
# operations = parse_input('(a*|b*) c')
operations = remove_empty(operations)
# operations = [['a', '*', '|', 'b', '*'], ' ', 'c']

print(operations)

# construct the tree based on the highest priority on the first level first
tree = create_node(operations)

# travel tree top down to assign parent to children
name_parents(tree, 'root')

# print the final state of the tree
print2D(tree)

# find the node we start building from
o = FindDeepestNode()
first = o.deepest_node(tree)


def get_highest(movement_list):
    curr_highest = 0
    for movement in movement_list:
        if movement[0] > curr_highest:
            curr_highest = movement[0]
        if movement[2] > curr_highest:
            curr_highest = movement[2] 

    return curr_highest


# transform the basic node to automata
# LEFT AND RIGHT NOT TYPE NODE
def automatize_Node(current_Node):
    left = current_Node.left
    right = current_Node.right
    operand = current_Node.operation

    if isinstance(current_Node.right, Node):
        right = current_Node.right.automata
    else:
        right = current_Node.right

    if isinstance(current_Node.left, Node):
        left = current_Node.left.automata
    else:
        left = current_Node.left
    
    if isinstance(right, dict):
        if isinstance(left, dict):
            left = renumber(left, right['start_end'][1][0])
            # delta = left['start_end'][1][0] + right['start_end'][1][0] 
            delta = get_highest(left['transitions']) + 7
        else:
            # delta = right['start_end'][1][0]
            delta = get_highest(right['transitions'])
    else:
        if isinstance(left, dict):
            left = renumber(left, 7)
        delta = 7

    # check the operation so we can raise a function based of this
    # CONCAT
    if operand == ' ':
        # raise a concat function and return the automata from this
        t_transitions, t_startend = copy.deepcopy(create_and([left, right], delta))
        t_automata = copy.deepcopy(automata_template)
        t_automata['start_end'] = t_startend
        t_automata['transitions'] = t_transitions
        return t_automata
    if operand == '|':
        # return an or statement automata from this node
        t_transitions, t_startend = copy.deepcopy(create_or([left, right], delta))
        t_automata = copy.deepcopy(automata_template)
        t_automata['start_end'] = t_startend
        t_automata['transitions'] = t_transitions
        return t_automata
    if operand == '*':
        # raise kleene function and return automata generated by it
        t_transitions, t_startend = copy.deepcopy(create_kleene([left, right], delta))
        t_automata = copy.deepcopy(automata_template)
        t_automata['start_end'] = t_startend
        t_automata['transitions'] = t_transitions
        return t_automata
    if operand == '+':
        # raise a plus funcion and return automata generate by it
        t_transitions, t_startend = copy.deepcopy(create_plus([left, right], delta))
        t_automata = copy.deepcopy(automata_template)
        t_automata['start_end'] = t_startend
        t_automata['transitions'] = t_transitions
        return t_automata
    if operand == '?':
        # raise a qmark function and return automata generated by it
        t_transitions, t_startend = copy.deepcopy(create_qmark([left, right], delta))
        t_automata = copy.deepcopy(automata_template)
        t_automata['start_end'] = t_startend
        t_automata['transitions'] = t_transitions
        return t_automata


def renumber(automata_dict, top_number):
    # change the numerator of each interation
    for state in automata_dict['start_end']:
        state[0] += top_number
        state[1] += top_number

    for transition in automata_dict['transitions']:
        transition[0] += top_number
        transition[2] += top_number
    
    return(automata_dict)



tree.left.right.automata = automatize_Node(tree.left.right)
tree.left.automata = automatize_Node(tree.left)
# tree.left.automata = automatize_Node(tree.left)
# tree.right.automata = automatize_Node(tree.right)
tree.automata = automatize_Node(tree)

graficadora(tree.automata['transitions'], tree.automata['start_end'])


# tree.left.right.automata = automatize_Node(tree.left.right)
# tree.left.automata = automatize_Node(tree.left)
# tree.right.automata = automatize_Node(tree.right)

# print(tree.left.automata)

# tree.automata = automatize_Node(tree)
# print(tree.automata)

# t1 = copy.deepcopy(automata_template)
# t1['transitions'], t1['start_end'] = create_kleene([0, tree.right.automata], 100)


# print(automatize_Node_plus(first))


# t2 = copy.deepcopy(automata_template)
# t2['transitions'], t2['start_end'] = create_or(['a', 'a'], 7)

# # transitions, start_end = create_or([t1, t2], 14)
# transitions, start_end = create_qmark([0, t1], 4)

# graficadora(tree.automata['transitions'], tree.automata['start_end'])


# print(str(first.left) + str(first.operation) + str(first.right))
# print(tree.parent)
# print(tree)
# print(tree.right.parent)
# print(tree.left.parent)
# print(tree.right.right.parent)
# print(tree.right.right.right)
# print(tree.right.right.operation)
# print(tree.right.right.left)
